# Secrets manager (AWS Service)
#### [ðŸ”™ back to index](../README.md)

It is a service that offers secure storage for credentials of different kinds: database credentials, API keys, and OAuth tokens.

It has secondary features around this like: rotation, monitor, control.

A secret can be any of:
1. Credentials for Amazon RDS database
2. Credentials for Amazon DocumentDB database
3. Credentials for Amazon Redshift data warehouse
4. Credentials for other database
5. Other type of secret (API key, OAuth token, other)

Â°1 to Â°4 will store username+password

Â°5 will store key/value pairs (a 1-level json fashion) or a plain text (can be a string or a multi-nested json)

## What is/does?

- Stores secrets of different kinds
- Has rotation capabilities (scheduled, manual, or customizable with a rotation lambda)
- Has out of the box encryption with the default encryption key `aws/secretsmanager` or with a custom encryption key (managed with AWS KMS)

## What problem solves?

If your application needs secrets for some operations (consuming 3rd party APIs, accessing a Database, signing/decoding a JWT, etc), you need a secure way to store those secrets. It can be dangerous to store all those secrets in a text or config file.
- With this service you can store them in a secure (encrypted) way

If you manage secrets, you need to rotate them with certain frequency (depending on different factors)
- With this service you can have manual rotations or automatic rotations (a lambda that can cover the most peculiar secret rotation needs)

## Pros/Cons

Pros
- Secrets can be flexible values:
  - key/value pairs (multiple per secret)
  - free txt (string or big nested json)
- Encryption by default (with the keys managed by KMS or yourself)
- Rotation capabilities (manual or scheduled)

Cons
- Network calls needed to fetch at runtime

## Is it worth using? If so, what scenario

It is worth using if you have strong need for storing secrets and you are cloud native, since plenty of pieces are serverless, you cannot store state in almost any runtime.

A naive approach could be to store secrets in a file in S3. In which case you wouldn't want to store that unencrypted, but then to decrypt that file, you need _another_ secret. At some point you will need a master secret that has to be stored securely somewhere. In that scenario is better to leverage a service like AWS Secrets Manager.

Is also worth noting that it can also solve the rotation needs that _many_ secrets need (scheduled rotation, ability to rotate immediately).

If you don't have a strong need for storing secrets then you can be ok without it.

In which scenario(s) is ok to _have secrets_, without using this service? (ok doesnt=good practice here)
- If those secrets are not the single protection to use certain service. For example a resource A might have the secret to encode/decode JWTs generated by resource B, but a resource might also require certain policies to be able to interact with resource B; in this scenario a resource C with the secret, but without the required policies to interact with resource B, cannot do anything.

## Extra topics

### Versions

Each secret in Secrets Manager can have Versions. This are versioned values of the secret, as its name implies, which main properties are:
- `Version ID`: UUID of the Version
- `Staging labels`: a set of 0 to 2 labels/tags, that can be any of:
    - `AWSPENDING`: this should be a temporary tag only, it marks the Version to be in a pending state, mostly meaning that is in the middle of a rotation cycle (probably the "new" Version soon to be the `AWSCURRENT` one)
    - `AWSPREVIOUS`: this marks the Version as the last known before the current Version (`AWSCURRENT`). A Version can only be labelled with this if there is a current Version
    - `AWSCURRENT`: this marks the Version as the current one.

### Rotation Cycle

The automatic rotation of secrets stored in this service can be done through a lambda, often referred as a "rotation lambda". To make this work, both the lambda and Secrets Manager require bilateral permissions (to invoke, read, write). In addition to that, the lambda needs to handle 4 events, that will be triggered in sequence (assuming no failure):

```json
{
  "ClientRequestToken": "VERSION-UUID", // same UUID per event
  "RotationToken": "ROTATION-EVENT-UUID", // different UUID per event
  "SecretId": "arn:aws:secretsmanager:REGION:ACCOUNT:secret:SECRET-NAME",
  "Step": "createSecret" // createSecret|setSecret|testSecret|finishSecret
}
```

For simplicity, the current Version before the rotation is going to be referred as `A`, and the new Version introduced by the rotation is going to be referred as `B`. The 4 events that the lambda will be:
1. `createSecret`: this step will do a bootstrap of the new Version (`B`), in order for the Version to exist in the next step(s), it should be labelled with the Version Stage label `AWSPENDING`
2. `setSecret`: this step might be optional. Assuming the secret content was properly set on creation, on the `createSecret` step. Here you might store or use the new credentials/secret in other service. For example if the secret stores DB credentials, you might want to update those DB credentials in this step (remember to fallback to the old credentials in case of failure of any of the following steps).
3. `testSecret`: this step is optional depending on the nature of the secret. Here you might test the secret agains a service, to check if the new credentials actually work.
4. `finishSecret`: this step will finish the rotation process by doing any updates to the new secret Version (`B`), if needed, but it will mainly perform two operations:
   1. Move the stage label `AWSCURRENT` from the current Version (`A`) to the new Version (`B`): after this operation, Version `A` will automatically get the stage label `AWSPREVIOUS`, and Version `B` will have two stage labels: `AWSPENDING` and `AWSCURRENT`
   2. Remove the stage label `AWSPENDING` from the new Version (`B`): after this operation Version `A` will have stage label `AWSPREVIOUS`, and Version `B` will have the stage label `AWSCURRENT` only. If this step is not done, any following rotation wont be able to start since there will be a "Hanging" Version labelled as `AWSPENDING`
